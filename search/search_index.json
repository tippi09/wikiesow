{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Coding Wiki Raspberry Pi HiFiPi: Multi-purpose Raspbian setup Configure SSH over IPv6 Improving Raspotify by configuring a LIRC IR remote (coming soon) macOS Basic macOS setup \u00dcbersicht: System monitor configuration BitBar: Menu bar plugins","title":"Coding Wiki"},{"location":"#coding-wiki","text":"","title":"Coding Wiki"},{"location":"#raspberry-pi","text":"HiFiPi: Multi-purpose Raspbian setup Configure SSH over IPv6 Improving Raspotify by configuring a LIRC IR remote (coming soon)","title":"Raspberry Pi"},{"location":"#macos","text":"Basic macOS setup \u00dcbersicht: System monitor configuration BitBar: Menu bar plugins","title":"macOS"},{"location":"Raspberry_Pi/irremote/","text":"Improving Raspotify by configuring a LIRC IR remote (coming soon)","title":"Improving Raspotify by configuring a LIRC IR remote (coming soon)"},{"location":"Raspberry_Pi/irremote/#improving-raspotify-by-configuring-a-lirc-ir-remote-coming-soon","text":"","title":"Improving Raspotify by configuring a LIRC IR remote (coming soon)"},{"location":"Raspberry_Pi/semihead/","text":"Multi-purpose Raspbian setup In this guide we will setup Raspbian on a Raspberry Pi so that it can be used for many purposes while keeping energy consumption as low as possible. Therefor we mainly run Raspbian headless and enable graphical output only if necessary (e.g. for media uses with Kodi). Download Raspbian image First of all download the latest Raspbian Desktop image from raspberrypi.org (Note: Do not use the Raspbian Lite image if you want to get graphical output as well) . Extract the zip file and remove it afterwards. Make sure to adjust the date if necessary: # unzip 2018 -11-13-raspbian-stretch.zip # rm 2018 -11-13-raspbian-stretch.zip Write image to the SD Card To write the image we have to find our SD card first. On macOS we run diskutil list with the SD card still unplugged . Then you can insert the card and run diskutil list once more. You should see another device listed as a new entry just like this one: /dev/disk2 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *32.0 GB disk2 1: DOS_FAT_32 LABEL 32.0 GB disk2s1 Danger Make sure to replace the disk number (disk2 to disk#) corresponding to your diskutil list output before calling the following statements. With the identifier of the SD card we can now unmount it before writing the image: # diskutil unmountDisk /dev/disk2 Now use dd to write the image: # sudo dd bs = 1m if = 2018 -11-13-raspbian-stretch.img of = /dev/rdisk2 conv = sync Note If this command fails you can try using disk2 instead of rdisk2 : # sudo dd bs = 1m if = 2018 -11-13-raspbian-stretch.img of = /dev/disk2 conv = sync After the dd command has finished writing the data you can eject the card: # sudo diskutil eject /dev/rdisk2 Now insert the SD card into your Raspberry and boot Raspbian for the first time. Default user and root password settings After completing the initial configuration process you should enable SSH (if not already done) and login to your Raspberry via SSH. The default credentials are: User: pi Password: raspberry # ssh pi@raspberrypi First change the default root password by calling passwd root and create a new user for SSH access: # adduser \u00abuser\u00bb # usermod -a -G sudo \u00abuser\u00bb After testing sudo access with the created user the default user pi can be deleted: # deluser -remove-home pi General Raspbian settings A nice tool to easily adjust settings for Raspbian is the raspi-config . After using SSH to login to your Raspberry it can be started by calling: # sudo raspi-config After running the aforementioned statement, navigate to Network Options - Hostname . Here you can change the default hostname raspberrypi to a new name you prefer. Afterwards go to Boot Options - Desktop / CLI in raspi-config . Choose the console option to avoid booting the more expensive desktop mode after a restart. Configure boot configuration Now we can configure some services and device trees to be loaded on boot. All the options in this section are set in the /boot/config.txt file: # sudo vim /boot/config.txt Disable HDMI output Do disable complete HDMI output on boot and avoid that the Raspberry turns on a connected TV with a HDMI-CEC event, add the following lines in your config.txt : # uncomment to enable hdmi output on boot hdmi_blanking=2 hdmi_ignore_cec_init=1 Disable WiFi and Bluetooth Danger Do not disable WiFi if you need it for SSH. Otherwise you could lock yourself out of your own system. As I do not need the Bluetooth of my Raspberry and with it being connected to the internet via LAN, I turn off the WiFi and Bluetooth modules to save some energy by adding the following lines to my config.txt : # uncomment to enable wifi and bluetooth dtoverlay=pi3-disable-wifi dtoverlay=pi3-disable-bt Load HiFiBerry device tree As my HiFi system is connected to my Raspberry, I am using a HiFiBerry board for an improved sound experience. To load the correct device tree and disable the onboard, I added the following lines to my config.txt : # Disabled onboard audio, loaded HiFiBerry device tree # dtparam=audio=on dtoverlay=hifiberry-dac Note The device tree that you have to load for your HiFiBerry depends on the concrete board you use. I am using a DAC+ DSP. For information of device trees for different models, take a look here . To check out which sound card is loaded, reboot and afterwards call: # aplay -l You should see an output that looks something like this: **** Liste der Hardware-Ger\u00e4te (PLAYBACK) **** Karte 0: sndrpihifiberry [snd_rpi_hifiberry_dac], Ger\u00e4t 0: HifiBerry DAC HiFi pcm5102a-hifi-0 [] Sub-Ger\u00e4te: 1/1 Sub-Ger\u00e4t #0: subdevice #0 Configure Kodi Because of the fact that HDMI output per default is disabled in this configuration, we have to find a way to bring it on when starting Kodi. For that reason, I wrote a small script called kodi.sh , that enables me to start Kodi via SSH: if [ $1 = start ] # Start Kodi, turn TV on and change TV output to Pi input then vcgencmd display_power 1 POWERSTATUS = $( echo pow 0 | cec-client -s -d 1 ) case $POWERSTATUS in *standby* ) echo on 0 | cec-client -s echo as | cec-client RPI -s -d 1 ;; *off* ) echo on 0 | cec-client -s echo as | cec-client RPI -s -d 1 ;; *on* ) echo echo as | cec-client RPI -s -d 1 ;; * ) echo Error: Unknown TV power status esac nohup kodi elif [ $1 = stopkodi ] # Stop Kodi and disable Pi HDMI output again then vcgencmd display_power 0 pkill kodi elif [ $1 = stopkodiandtv ] # Stop Kodi, disable PI HDMI output and set TV to standby then echo standby 0 | cec-client -s vcgencmd display_power 0 pkill kodi fi After creating the script you have to make it executable by running: # chmod +x /path/to/kodi.sh As the script has to be run with sudo , we have to enable your user to do so by editing the /etc/sudoers.tmp file: # sudo visudo Add the following line: \u00abuser\u00bb ALL= NOPASSWD: /path/to/kodi.sh Now it should be possible to run the script by running: # ssh -t \u00abuser\u00bb@\u00abhostname\u00bb sudo /path/to/kodi.sh \u00aboption\u00bb With the following options available: start Starts Kodi, turns the TV on if necessary by checking the current power status and changes the TV output to the Pis input. stopkodi Stops Kodi, disables the Pis HDMI output once again and keeps the TV turned on (in case you want to use it differently). stopkodiandtv Stops Kodi, disables the Pis HDMI output once again and turns the TV into standby mode. As a result, just run the following command to start Kodi: # ssh -t \u00abuser\u00bb@\u00abhostname\u00bb sudo /path/to/kodi.sh start To make starting and stopping Kodi from my Mac easier, I have also written a script for Bitbar . My BitBar setup is documented here as well. If you have problems with the Kodi output, update Kodi and check your overscan options in /boot/config.txt . Install Raspotify If you would like to use your Raspberry Pi as a Spotify connect client, it is recommended to use the Raspotify project. To install Raspotify we use the provided install script: # curl -L https://dtcooper.github.io/raspotify/install.sh raspotify.sh # chmod +x raspotify.sh If you are certain that the script is harmless, run it: # ./raspotify.sh To configure your Spotify client, just edit the /etc/default/raspotify file. For example, I changed the clients device name and the bitrate to higher quality by adding the lines: DEVICE_NAME= HiFiPi # default is raspotify BITRATE= 320 # default is 160","title":"Multi-purpose Raspbian setup"},{"location":"Raspberry_Pi/semihead/#multi-purpose-raspbian-setup","text":"In this guide we will setup Raspbian on a Raspberry Pi so that it can be used for many purposes while keeping energy consumption as low as possible. Therefor we mainly run Raspbian headless and enable graphical output only if necessary (e.g. for media uses with Kodi).","title":"Multi-purpose Raspbian setup"},{"location":"Raspberry_Pi/semihead/#download-raspbian-image","text":"First of all download the latest Raspbian Desktop image from raspberrypi.org (Note: Do not use the Raspbian Lite image if you want to get graphical output as well) . Extract the zip file and remove it afterwards. Make sure to adjust the date if necessary: # unzip 2018 -11-13-raspbian-stretch.zip # rm 2018 -11-13-raspbian-stretch.zip","title":"Download Raspbian image"},{"location":"Raspberry_Pi/semihead/#write-image-to-the-sd-card","text":"To write the image we have to find our SD card first. On macOS we run diskutil list with the SD card still unplugged . Then you can insert the card and run diskutil list once more. You should see another device listed as a new entry just like this one: /dev/disk2 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *32.0 GB disk2 1: DOS_FAT_32 LABEL 32.0 GB disk2s1 Danger Make sure to replace the disk number (disk2 to disk#) corresponding to your diskutil list output before calling the following statements. With the identifier of the SD card we can now unmount it before writing the image: # diskutil unmountDisk /dev/disk2 Now use dd to write the image: # sudo dd bs = 1m if = 2018 -11-13-raspbian-stretch.img of = /dev/rdisk2 conv = sync Note If this command fails you can try using disk2 instead of rdisk2 : # sudo dd bs = 1m if = 2018 -11-13-raspbian-stretch.img of = /dev/disk2 conv = sync After the dd command has finished writing the data you can eject the card: # sudo diskutil eject /dev/rdisk2 Now insert the SD card into your Raspberry and boot Raspbian for the first time.","title":"Write image to the SD Card"},{"location":"Raspberry_Pi/semihead/#default-user-and-root-password-settings","text":"After completing the initial configuration process you should enable SSH (if not already done) and login to your Raspberry via SSH. The default credentials are: User: pi Password: raspberry # ssh pi@raspberrypi First change the default root password by calling passwd root and create a new user for SSH access: # adduser \u00abuser\u00bb # usermod -a -G sudo \u00abuser\u00bb After testing sudo access with the created user the default user pi can be deleted: # deluser -remove-home pi","title":"Default user and root password settings"},{"location":"Raspberry_Pi/semihead/#general-raspbian-settings","text":"A nice tool to easily adjust settings for Raspbian is the raspi-config . After using SSH to login to your Raspberry it can be started by calling: # sudo raspi-config After running the aforementioned statement, navigate to Network Options - Hostname . Here you can change the default hostname raspberrypi to a new name you prefer. Afterwards go to Boot Options - Desktop / CLI in raspi-config . Choose the console option to avoid booting the more expensive desktop mode after a restart.","title":"General Raspbian settings"},{"location":"Raspberry_Pi/semihead/#configure-boot-configuration","text":"Now we can configure some services and device trees to be loaded on boot. All the options in this section are set in the /boot/config.txt file: # sudo vim /boot/config.txt","title":"Configure boot configuration"},{"location":"Raspberry_Pi/semihead/#disable-hdmi-output","text":"Do disable complete HDMI output on boot and avoid that the Raspberry turns on a connected TV with a HDMI-CEC event, add the following lines in your config.txt : # uncomment to enable hdmi output on boot hdmi_blanking=2 hdmi_ignore_cec_init=1","title":"Disable HDMI output"},{"location":"Raspberry_Pi/semihead/#disable-wifi-and-bluetooth","text":"Danger Do not disable WiFi if you need it for SSH. Otherwise you could lock yourself out of your own system. As I do not need the Bluetooth of my Raspberry and with it being connected to the internet via LAN, I turn off the WiFi and Bluetooth modules to save some energy by adding the following lines to my config.txt : # uncomment to enable wifi and bluetooth dtoverlay=pi3-disable-wifi dtoverlay=pi3-disable-bt","title":"Disable WiFi and Bluetooth"},{"location":"Raspberry_Pi/semihead/#load-hifiberry-device-tree","text":"As my HiFi system is connected to my Raspberry, I am using a HiFiBerry board for an improved sound experience. To load the correct device tree and disable the onboard, I added the following lines to my config.txt : # Disabled onboard audio, loaded HiFiBerry device tree # dtparam=audio=on dtoverlay=hifiberry-dac Note The device tree that you have to load for your HiFiBerry depends on the concrete board you use. I am using a DAC+ DSP. For information of device trees for different models, take a look here . To check out which sound card is loaded, reboot and afterwards call: # aplay -l You should see an output that looks something like this: **** Liste der Hardware-Ger\u00e4te (PLAYBACK) **** Karte 0: sndrpihifiberry [snd_rpi_hifiberry_dac], Ger\u00e4t 0: HifiBerry DAC HiFi pcm5102a-hifi-0 [] Sub-Ger\u00e4te: 1/1 Sub-Ger\u00e4t #0: subdevice #0","title":"Load HiFiBerry device tree"},{"location":"Raspberry_Pi/semihead/#configure-kodi","text":"Because of the fact that HDMI output per default is disabled in this configuration, we have to find a way to bring it on when starting Kodi. For that reason, I wrote a small script called kodi.sh , that enables me to start Kodi via SSH: if [ $1 = start ] # Start Kodi, turn TV on and change TV output to Pi input then vcgencmd display_power 1 POWERSTATUS = $( echo pow 0 | cec-client -s -d 1 ) case $POWERSTATUS in *standby* ) echo on 0 | cec-client -s echo as | cec-client RPI -s -d 1 ;; *off* ) echo on 0 | cec-client -s echo as | cec-client RPI -s -d 1 ;; *on* ) echo echo as | cec-client RPI -s -d 1 ;; * ) echo Error: Unknown TV power status esac nohup kodi elif [ $1 = stopkodi ] # Stop Kodi and disable Pi HDMI output again then vcgencmd display_power 0 pkill kodi elif [ $1 = stopkodiandtv ] # Stop Kodi, disable PI HDMI output and set TV to standby then echo standby 0 | cec-client -s vcgencmd display_power 0 pkill kodi fi After creating the script you have to make it executable by running: # chmod +x /path/to/kodi.sh As the script has to be run with sudo , we have to enable your user to do so by editing the /etc/sudoers.tmp file: # sudo visudo Add the following line: \u00abuser\u00bb ALL= NOPASSWD: /path/to/kodi.sh Now it should be possible to run the script by running: # ssh -t \u00abuser\u00bb@\u00abhostname\u00bb sudo /path/to/kodi.sh \u00aboption\u00bb With the following options available: start Starts Kodi, turns the TV on if necessary by checking the current power status and changes the TV output to the Pis input. stopkodi Stops Kodi, disables the Pis HDMI output once again and keeps the TV turned on (in case you want to use it differently). stopkodiandtv Stops Kodi, disables the Pis HDMI output once again and turns the TV into standby mode. As a result, just run the following command to start Kodi: # ssh -t \u00abuser\u00bb@\u00abhostname\u00bb sudo /path/to/kodi.sh start To make starting and stopping Kodi from my Mac easier, I have also written a script for Bitbar . My BitBar setup is documented here as well. If you have problems with the Kodi output, update Kodi and check your overscan options in /boot/config.txt .","title":"Configure Kodi"},{"location":"Raspberry_Pi/semihead/#install-raspotify","text":"If you would like to use your Raspberry Pi as a Spotify connect client, it is recommended to use the Raspotify project. To install Raspotify we use the provided install script: # curl -L https://dtcooper.github.io/raspotify/install.sh raspotify.sh # chmod +x raspotify.sh If you are certain that the script is harmless, run it: # ./raspotify.sh To configure your Spotify client, just edit the /etc/default/raspotify file. For example, I changed the clients device name and the bitrate to higher quality by adding the lines: DEVICE_NAME= HiFiPi # default is raspotify BITRATE= 320 # default is 160","title":"Install Raspotify"},{"location":"Raspberry_Pi/ssh6/","text":"Configure SSH over IPv6 In this guide we will configure SSH on a Raspberry Pi so that it can be reached via IPv6 even from an outside network. This is especially useful if your ISP only grants a Dual-Stack Lite connection. Raspberry Pi settings At first we have to enable the Pis IPv6-module by editing the /etc/modules file: # sudo vim /etc/modules Add the following line at the end of the file: ipv6 After a reboot you can check if your Raspberry now has an IPv6 address by calling the statement ip a . To make sure that your SSH client also accepts connections via IPv6 and not only via IPv4, we have to adjust the corresponding config file: # sudo vim /etc/ssh/sshd_config Look for a line that begins with AddressFamily and make sure it is not set to inet (IPv4 use only). You can decide if you would like to enable IPv4 and IPv6 connections (by using any ), or if you go for IPv6 connections only ( inet6 ). I decided to enable both communication protocols, so that my line looks like this: AddressFamily any If you like, you can also disable password authentification for SSH access, this would improve security by forcing clients to use SSH-keys instead. For further instructions on how to setup SSH-keys take a look here . To disable password authentification just set the following line in your sshd_config : PasswordAuthentication no Router settings To make sure your internet router also works with IPv6 DS Lite and that it assigns global IPv6 addresses to your local devices (including your Raspberry Pi), some adjustments might have to be made (Note: These settings depend on the router you use. I'm using an AVM Fritzbox, whose configuration can differ from your router) . At first I make sure my router uses a native IPv6-connection instead of IPv4 tunneling for IPv6 connectivity by setting the following in Zugangsdaten - IPv6 : Afterwards we configure our DHCPv6 server in Netzwerk - Netzwerkeinstellungen - IPv6 Adressen , so that it assigns IPv6 addresses from your address range to the devices you are port forwarding, making them directly addressable from the internet: TODO: Describe port forwarding At this point you should be able to connect to your Raspberry Pi from the internet via SSH using the following command: # ssh -6 user @ global ipv6 Configure Dynamic DNS (optional) By configuring DynDNS you can connect to your Raspberry by using a hostname instead of the complete IPv6 address. I'm using a hostname from dynv6.com as they support IPv6, but of course you are free to choose a different service. After creating a hostname we have to make sure the hostname is always pointing at the current IPv6 address of the Pi. Therefor I wrote a small script based on a script from dynv6.com : #!/bin/sh -e hostname = yourhostname device = $2 token = yourtoken file = $HOME /.dynv6.addr6 [ -e $file ] old = ` cat $file ` if [ -z $netmask ] ; then netmask = 128 fi if [ -n $device ] ; then device = dev $device fi address = $( ip -6 addr list scope global $device | grep -v fd | sed -n s/.*inet6 \\([0-9a-f:]\\+\\).*/\\1/p | head -n 1 ) if [ -e /usr/bin/curl ] ; then bin = curl -fsS elif [ -e /usr/bin/wget ] ; then bin = wget -O- else echo neither curl nor wget found exit 1 fi if [ -z $address ] ; then echo no IPv6 address found exit 1 fi # address with netmask current = $address / $netmask if [ $old = $current ] ; then echo IPv6 address unchanged exit fi # send addresses to dynv6 $bin http://dynv6.com/api/update?hostname= $hostname ipv6= $current token= $token $bin http://ipv4.dynv6.com/api/update?hostname= $hostname ipv4=auto token= $token # save current address echo $current $file This script sends the latest IPv4 and IPv6 address to dynv6 if the adresses have changed, so that your hostname always points to the right direction. I have saved the script in my Raspberry Pis home directory in a file called dynv6.sh. Before we proceed, make sure you can execute the script: # chmod +x /path/to/dynv6.sh Now we can configure a cronjob that executes the script every 5 minutes, keeping the hostname updated: # crontab -e Now add a line that looks like this: */5 * * * * /path/to/dynv6.sh Now you should be able to connect to your Raspberry by using ssh -6 user @ your hostname instead of your IPv6 address only. You can also use your own subdomain name by configuring a CNAME record pointing to the DynDNS hostname in your DNS configuration.","title":"Configure SSH over IPv6"},{"location":"Raspberry_Pi/ssh6/#configure-ssh-over-ipv6","text":"In this guide we will configure SSH on a Raspberry Pi so that it can be reached via IPv6 even from an outside network. This is especially useful if your ISP only grants a Dual-Stack Lite connection.","title":"Configure SSH over IPv6"},{"location":"Raspberry_Pi/ssh6/#raspberry-pi-settings","text":"At first we have to enable the Pis IPv6-module by editing the /etc/modules file: # sudo vim /etc/modules Add the following line at the end of the file: ipv6 After a reboot you can check if your Raspberry now has an IPv6 address by calling the statement ip a . To make sure that your SSH client also accepts connections via IPv6 and not only via IPv4, we have to adjust the corresponding config file: # sudo vim /etc/ssh/sshd_config Look for a line that begins with AddressFamily and make sure it is not set to inet (IPv4 use only). You can decide if you would like to enable IPv4 and IPv6 connections (by using any ), or if you go for IPv6 connections only ( inet6 ). I decided to enable both communication protocols, so that my line looks like this: AddressFamily any If you like, you can also disable password authentification for SSH access, this would improve security by forcing clients to use SSH-keys instead. For further instructions on how to setup SSH-keys take a look here . To disable password authentification just set the following line in your sshd_config : PasswordAuthentication no","title":"Raspberry Pi settings"},{"location":"Raspberry_Pi/ssh6/#router-settings","text":"To make sure your internet router also works with IPv6 DS Lite and that it assigns global IPv6 addresses to your local devices (including your Raspberry Pi), some adjustments might have to be made (Note: These settings depend on the router you use. I'm using an AVM Fritzbox, whose configuration can differ from your router) . At first I make sure my router uses a native IPv6-connection instead of IPv4 tunneling for IPv6 connectivity by setting the following in Zugangsdaten - IPv6 : Afterwards we configure our DHCPv6 server in Netzwerk - Netzwerkeinstellungen - IPv6 Adressen , so that it assigns IPv6 addresses from your address range to the devices you are port forwarding, making them directly addressable from the internet: TODO: Describe port forwarding At this point you should be able to connect to your Raspberry Pi from the internet via SSH using the following command: # ssh -6 user @ global ipv6","title":"Router settings"},{"location":"Raspberry_Pi/ssh6/#configure-dynamic-dns-optional","text":"By configuring DynDNS you can connect to your Raspberry by using a hostname instead of the complete IPv6 address. I'm using a hostname from dynv6.com as they support IPv6, but of course you are free to choose a different service. After creating a hostname we have to make sure the hostname is always pointing at the current IPv6 address of the Pi. Therefor I wrote a small script based on a script from dynv6.com : #!/bin/sh -e hostname = yourhostname device = $2 token = yourtoken file = $HOME /.dynv6.addr6 [ -e $file ] old = ` cat $file ` if [ -z $netmask ] ; then netmask = 128 fi if [ -n $device ] ; then device = dev $device fi address = $( ip -6 addr list scope global $device | grep -v fd | sed -n s/.*inet6 \\([0-9a-f:]\\+\\).*/\\1/p | head -n 1 ) if [ -e /usr/bin/curl ] ; then bin = curl -fsS elif [ -e /usr/bin/wget ] ; then bin = wget -O- else echo neither curl nor wget found exit 1 fi if [ -z $address ] ; then echo no IPv6 address found exit 1 fi # address with netmask current = $address / $netmask if [ $old = $current ] ; then echo IPv6 address unchanged exit fi # send addresses to dynv6 $bin http://dynv6.com/api/update?hostname= $hostname ipv6= $current token= $token $bin http://ipv4.dynv6.com/api/update?hostname= $hostname ipv4=auto token= $token # save current address echo $current $file This script sends the latest IPv4 and IPv6 address to dynv6 if the adresses have changed, so that your hostname always points to the right direction. I have saved the script in my Raspberry Pis home directory in a file called dynv6.sh. Before we proceed, make sure you can execute the script: # chmod +x /path/to/dynv6.sh Now we can configure a cronjob that executes the script every 5 minutes, keeping the hostname updated: # crontab -e Now add a line that looks like this: */5 * * * * /path/to/dynv6.sh Now you should be able to connect to your Raspberry by using ssh -6 user @ your hostname instead of your IPv6 address only. You can also use your own subdomain name by configuring a CNAME record pointing to the DynDNS hostname in your DNS configuration.","title":"Configure Dynamic DNS (optional)"},{"location":"macOS/basic/","text":"Basic macOS setup In this guide I will explain my basic macOS setup which includes my Vim and zsh configuration, as well as the installment of useful software like Homebrew . Install Homebrew Sadly macOS does not include a preinstalled package manager. This problem can be solved with Homebrew, which can be installed easily by running: # /usr/bin/ruby -e $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) When the installation process has finished you can install and uninstall software simple and clean by using brew install or brew install . To search for a software package, just type brew search . Install thefuck With Homebrew, we can now install thefuck , a handy tool which is able to correct your previous console command. # brew install thefuck Configure thefuck in your shells startup script This step is only necessary if you do not want to use my zsh setup described here. In that case, you have to add the following command in your .bash_profile , .bashrc , .zshrc or another startup script: # eval $( thefuck --alias ) Now you should be able to type fuck in your terminal and get your commands corrected if they fail. The evaluation of thefuck is already contained in the following .zshrc configuration I am using. If you think fuck is a too vulgar alias for this command, you are of course free to change it to anything you like. Configure Vim and zsh For my Vim and zsh configuration I am using the .dotfiles repository by rngcntr . First we have to clone the repository: # cd ~ # git clone git@bitbucket.org:rngcntr/.dotfiles.git .dotfiles # cd .dotfiles/ # git submodule init # git submodule update Now we can create symlinks to use the configuration files in our ~/.dotfiles directory. First we set our .vimrc , install Vundle with plugins and afterwards link the .zshrc : # cd ~ # git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim # ln -s .dotfiles/.vimrc .vimrc # vim +PluginInstall +qall # ln -s .dotfiles/.zshrc .zshrc You can check if the links work by running ls -l .vimrc and ls -l .zshrc in your home directory. You should see an output that looks similar to this: .vimrc - .dotfiles / .vimrc .zshrc - .dotfiles / .zshrc Now we improve the terminal experience by installing and configuring oh-my-zsh : # cd ~ # ln -s .dotfiles/.oh-my-zsh .oh-my-zsh # ./.oh-my-zsh/tools/install.sh After installing oh-my-zsh the zsh should be set as your default shell. If this is not the case, just run chsh -s $(which zsh) .","title":"Basic macOS setup"},{"location":"macOS/basic/#basic-macos-setup","text":"In this guide I will explain my basic macOS setup which includes my Vim and zsh configuration, as well as the installment of useful software like Homebrew .","title":"Basic macOS setup"},{"location":"macOS/basic/#install-homebrew","text":"Sadly macOS does not include a preinstalled package manager. This problem can be solved with Homebrew, which can be installed easily by running: # /usr/bin/ruby -e $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) When the installation process has finished you can install and uninstall software simple and clean by using brew install or brew install . To search for a software package, just type brew search .","title":"Install Homebrew"},{"location":"macOS/basic/#install-thefuck","text":"With Homebrew, we can now install thefuck , a handy tool which is able to correct your previous console command. # brew install thefuck Configure thefuck in your shells startup script This step is only necessary if you do not want to use my zsh setup described here. In that case, you have to add the following command in your .bash_profile , .bashrc , .zshrc or another startup script: # eval $( thefuck --alias ) Now you should be able to type fuck in your terminal and get your commands corrected if they fail. The evaluation of thefuck is already contained in the following .zshrc configuration I am using. If you think fuck is a too vulgar alias for this command, you are of course free to change it to anything you like.","title":"Install thefuck"},{"location":"macOS/basic/#configure-vim-and-zsh","text":"For my Vim and zsh configuration I am using the .dotfiles repository by rngcntr . First we have to clone the repository: # cd ~ # git clone git@bitbucket.org:rngcntr/.dotfiles.git .dotfiles # cd .dotfiles/ # git submodule init # git submodule update Now we can create symlinks to use the configuration files in our ~/.dotfiles directory. First we set our .vimrc , install Vundle with plugins and afterwards link the .zshrc : # cd ~ # git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim # ln -s .dotfiles/.vimrc .vimrc # vim +PluginInstall +qall # ln -s .dotfiles/.zshrc .zshrc You can check if the links work by running ls -l .vimrc and ls -l .zshrc in your home directory. You should see an output that looks similar to this: .vimrc - .dotfiles / .vimrc .zshrc - .dotfiles / .zshrc Now we improve the terminal experience by installing and configuring oh-my-zsh : # cd ~ # ln -s .dotfiles/.oh-my-zsh .oh-my-zsh # ./.oh-my-zsh/tools/install.sh After installing oh-my-zsh the zsh should be set as your default shell. If this is not the case, just run chsh -s $(which zsh) .","title":"Configure Vim and zsh"},{"location":"macOS/bitbar/","text":"BitBar: Menu bar plugins With BitBar you are able to put anything in your macOS menu bar. I have a repository containing all the BitBar plugins I am using, including a plugin which makes it easy to control my Kodi configuration from this guide . First of all it is recommended to install BitBar by using Homebrew : # brew cask install bitbar After installing you can create a directory for BitBar in /Applications/ to keep your plugins organized with the app itself: # cd /Applications/ # mkdir BitBar mv BitBar.app BitBar/ # cd BitBar/ Now clone my bitbar-plugin repository in a directory called plugins-repository : # git clone git@github.com:tippi09/bitbar-plugins.git plugins-repository To separate your own plugins from my repository we first create another directory called plugins-enabled : # mkdir plugins-enabled cd plugins-enabled Now create symlinks from the plugins-repository to the plugins-enabled directory. You can choose if you would like to use all of my BitBar plugins: # ln -s ../plugins-repository/* . Or just some of them like my Kodi addon: # ln -s ../plugins-repository/kodi.sh . Now start BitBar for the first time and set /Applications/BitBar/plugins-enabled as plugin folder. You can add your own plugins in the plugins-enabled directory and update my plugin repository in plugins-repository .","title":"BitBar: Menu bar plugins"},{"location":"macOS/bitbar/#bitbar-menu-bar-plugins","text":"With BitBar you are able to put anything in your macOS menu bar. I have a repository containing all the BitBar plugins I am using, including a plugin which makes it easy to control my Kodi configuration from this guide . First of all it is recommended to install BitBar by using Homebrew : # brew cask install bitbar After installing you can create a directory for BitBar in /Applications/ to keep your plugins organized with the app itself: # cd /Applications/ # mkdir BitBar mv BitBar.app BitBar/ # cd BitBar/ Now clone my bitbar-plugin repository in a directory called plugins-repository : # git clone git@github.com:tippi09/bitbar-plugins.git plugins-repository To separate your own plugins from my repository we first create another directory called plugins-enabled : # mkdir plugins-enabled cd plugins-enabled Now create symlinks from the plugins-repository to the plugins-enabled directory. You can choose if you would like to use all of my BitBar plugins: # ln -s ../plugins-repository/* . Or just some of them like my Kodi addon: # ln -s ../plugins-repository/kodi.sh . Now start BitBar for the first time and set /Applications/BitBar/plugins-enabled as plugin folder. You can add your own plugins in the plugins-enabled directory and update my plugin repository in plugins-repository .","title":"BitBar: Menu bar plugins"},{"location":"macOS/uebersicht/","text":"\u00dcbersicht: System monitor configuration With \u00dcbersicht you are able to configure an active system monitor on your macOS desktop. I have a repository containing all the \u00dcbersicht plugins I am using in my personal arrangement. Note I do not own all of the widgets contained in my repository but mainly made adjustments to them. Most of the widgets I use can originally be found here . First of all it is recommended to install \u00dcbersicht by using Homebrew : # brew cask install ubersicht After installing you can create a directory for \u00dcbersicht in /Applications/ to keep your plugins organized with the app itself: # cd /Applications/ # mkdir \u00dcbersicht mv \u00dcbersicht.app \u00dcbersicht/ # cd \u00dcbersicht/ Now clone my uebersicht-widgets repository in a directory called widgets-repository : # git clone git@github.com:tippi09/uebersicht-widgets.git widgets-repository To separate your own plugins from my repository we first create another directory called widgets-enabled : # mkdir widgets-enabled cd widgets-enabled Now create a symlink from the widgets-repository to the widgets-enabled directory. # ln -s ../widgets-repository/* . Now start \u00dcbersicht for the first time , set /Applications/\u00dcbersicht/widgets-enabled as widget folder in the preferences (available over the \u00dcbersicht icon in your menu bar) and restart \u00dcbersicht afterwards. You can add your own plugins in the widgets-enabled directory and update my widget repository in widgets-repository .","title":"\u00dcbersicht: System monitor configuration"},{"location":"macOS/uebersicht/#ubersicht-system-monitor-configuration","text":"With \u00dcbersicht you are able to configure an active system monitor on your macOS desktop. I have a repository containing all the \u00dcbersicht plugins I am using in my personal arrangement. Note I do not own all of the widgets contained in my repository but mainly made adjustments to them. Most of the widgets I use can originally be found here . First of all it is recommended to install \u00dcbersicht by using Homebrew : # brew cask install ubersicht After installing you can create a directory for \u00dcbersicht in /Applications/ to keep your plugins organized with the app itself: # cd /Applications/ # mkdir \u00dcbersicht mv \u00dcbersicht.app \u00dcbersicht/ # cd \u00dcbersicht/ Now clone my uebersicht-widgets repository in a directory called widgets-repository : # git clone git@github.com:tippi09/uebersicht-widgets.git widgets-repository To separate your own plugins from my repository we first create another directory called widgets-enabled : # mkdir widgets-enabled cd widgets-enabled Now create a symlink from the widgets-repository to the widgets-enabled directory. # ln -s ../widgets-repository/* . Now start \u00dcbersicht for the first time , set /Applications/\u00dcbersicht/widgets-enabled as widget folder in the preferences (available over the \u00dcbersicht icon in your menu bar) and restart \u00dcbersicht afterwards. You can add your own plugins in the widgets-enabled directory and update my widget repository in widgets-repository .","title":"\u00dcbersicht: System monitor configuration"}]}